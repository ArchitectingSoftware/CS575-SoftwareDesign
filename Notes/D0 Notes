Overall nice summary - some key points to consider﻿﻿﻿﻿﻿﻿﻿﻿:

On the criteria...: 

1.  one of the key points is on the criteria used to decompose the systems into modules - 
    different criteria lead to different outcomes, and therefore associated tradeoffs
2.  key point - modularity of a system is important to improving the flexibility and understandability
    of a system
3.  benefits of modularity (modular programming) - shorten development time, flexibility improvment,
    comprenhensibility
4.  The example given - modularize based on steps in a processing flow, or modularizing based on 
    information hiding - argues that the second is better.  Why?  in the first, a change is likely to
    require changes in many modules, versus the second will be more likely to isolate a change to a few
    (ideally one) module


Information distribution aspects

1.  one of the key points is that we tend to couple modules without thinking about things like the 
    interfaces that control the flow between the modules
2.  Releaseing 'information' outside of the team working on a module is harmful, just the interface
    is necessary
3.  Early definition of architecture - a system has structure - the set of modules in the system and the
    connections between them
4.  Isolation - what changes can be made to a module without requireing changes to others?
5.  Making decisions about the structure - during design we make decisions that eliminate some possibilities
    for the structure
6.  Define external characteristics first (aka focus on the architecture) prior to defining internal
    characteristics (aka the algorithms)
7.  Productivity - delivering the sytem quickly involves dividing up the system correctly
8.  Architecture connotation - the earlier a decision is made, the harder it is to change
9.  Key point - a good programmer makes use of all information provided, thus, controlling the information
    provided becomes important - in other words - be careful what information you make available
10. 


Software aging

1.  Paper drawing the analogy between how people age, and how software argues
2.  What causes software agining? failure of a products owner to meet its changing needs
3.  Key point, it cant be avoided, but it can be managed, and some suggestions are provided
4.  He also mentions how inexpirenced programmers or those not familiar with the system contribute to
    accelarating the aging process.

Id also be interested on your views how most companies are dealing with the topics in software aging... I actually am seeing more of the points in the aging paper are still true today - not paying attention to the health of the design, chasing new features, and so on.  